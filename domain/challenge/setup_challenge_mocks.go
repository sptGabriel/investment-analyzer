// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package challenge

import (
	"context"
	"github.com/sptGabriel/investment-analyzer/domain/entities"
	"github.com/sptGabriel/investment-analyzer/domain/ports"
	"sync"
)

// Ensure, that csvServicesMock does implement csvServices.
// If this is not the case, regenerate this file with moq.
var _ csvServices = &csvServicesMock{}

// csvServicesMock is a mock implementation of csvServices.
//
//	func TestSomethingThatUsescsvServices(t *testing.T) {
//
//		// make and configure a mocked csvServices
//		mockedcsvServices := &csvServicesMock{
//			GetPricesFunc: func() []ports.PriceCSVDTO {
//				panic("mock out the GetPrices method")
//			},
//			GetTradesFunc: func() []ports.TradeCSVDTO {
//				panic("mock out the GetTrades method")
//			},
//		}
//
//		// use mockedcsvServices in code that requires csvServices
//		// and then make assertions.
//
//	}
type csvServicesMock struct {
	// GetPricesFunc mocks the GetPrices method.
	GetPricesFunc func() []ports.PriceCSVDTO

	// GetTradesFunc mocks the GetTrades method.
	GetTradesFunc func() []ports.TradeCSVDTO

	// calls tracks calls to the methods.
	calls struct {
		// GetPrices holds details about calls to the GetPrices method.
		GetPrices []struct {
		}
		// GetTrades holds details about calls to the GetTrades method.
		GetTrades []struct {
		}
	}
	lockGetPrices sync.RWMutex
	lockGetTrades sync.RWMutex
}

// GetPrices calls GetPricesFunc.
func (mock *csvServicesMock) GetPrices() []ports.PriceCSVDTO {
	callInfo := struct {
	}{}
	mock.lockGetPrices.Lock()
	mock.calls.GetPrices = append(mock.calls.GetPrices, callInfo)
	mock.lockGetPrices.Unlock()
	if mock.GetPricesFunc == nil {
		var (
			priceCSVDTOsOut []ports.PriceCSVDTO
		)
		return priceCSVDTOsOut
	}
	return mock.GetPricesFunc()
}

// GetPricesCalls gets all the calls that were made to GetPrices.
// Check the length with:
//
//	len(mockedcsvServices.GetPricesCalls())
func (mock *csvServicesMock) GetPricesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetPrices.RLock()
	calls = mock.calls.GetPrices
	mock.lockGetPrices.RUnlock()
	return calls
}

// GetTrades calls GetTradesFunc.
func (mock *csvServicesMock) GetTrades() []ports.TradeCSVDTO {
	callInfo := struct {
	}{}
	mock.lockGetTrades.Lock()
	mock.calls.GetTrades = append(mock.calls.GetTrades, callInfo)
	mock.lockGetTrades.Unlock()
	if mock.GetTradesFunc == nil {
		var (
			tradeCSVDTOsOut []ports.TradeCSVDTO
		)
		return tradeCSVDTOsOut
	}
	return mock.GetTradesFunc()
}

// GetTradesCalls gets all the calls that were made to GetTrades.
// Check the length with:
//
//	len(mockedcsvServices.GetTradesCalls())
func (mock *csvServicesMock) GetTradesCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockGetTrades.RLock()
	calls = mock.calls.GetTrades
	mock.lockGetTrades.RUnlock()
	return calls
}

// Ensure, that settingsRepositoryMock does implement settingsRepository.
// If this is not the case, regenerate this file with moq.
var _ settingsRepository = &settingsRepositoryMock{}

// settingsRepositoryMock is a mock implementation of settingsRepository.
//
//	func TestSomethingThatUsessettingsRepository(t *testing.T) {
//
//		// make and configure a mocked settingsRepository
//		mockedsettingsRepository := &settingsRepositoryMock{
//			IsCsvImportedFunc: func(contextMoqParam context.Context) (bool, error) {
//				panic("mock out the IsCsvImported method")
//			},
//			SetCsvImportedFunc: func(contextMoqParam context.Context) error {
//				panic("mock out the SetCsvImported method")
//			},
//		}
//
//		// use mockedsettingsRepository in code that requires settingsRepository
//		// and then make assertions.
//
//	}
type settingsRepositoryMock struct {
	// IsCsvImportedFunc mocks the IsCsvImported method.
	IsCsvImportedFunc func(contextMoqParam context.Context) (bool, error)

	// SetCsvImportedFunc mocks the SetCsvImported method.
	SetCsvImportedFunc func(contextMoqParam context.Context) error

	// calls tracks calls to the methods.
	calls struct {
		// IsCsvImported holds details about calls to the IsCsvImported method.
		IsCsvImported []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// SetCsvImported holds details about calls to the SetCsvImported method.
		SetCsvImported []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
	}
	lockIsCsvImported  sync.RWMutex
	lockSetCsvImported sync.RWMutex
}

// IsCsvImported calls IsCsvImportedFunc.
func (mock *settingsRepositoryMock) IsCsvImported(contextMoqParam context.Context) (bool, error) {
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockIsCsvImported.Lock()
	mock.calls.IsCsvImported = append(mock.calls.IsCsvImported, callInfo)
	mock.lockIsCsvImported.Unlock()
	if mock.IsCsvImportedFunc == nil {
		var (
			bOut   bool
			errOut error
		)
		return bOut, errOut
	}
	return mock.IsCsvImportedFunc(contextMoqParam)
}

// IsCsvImportedCalls gets all the calls that were made to IsCsvImported.
// Check the length with:
//
//	len(mockedsettingsRepository.IsCsvImportedCalls())
func (mock *settingsRepositoryMock) IsCsvImportedCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockIsCsvImported.RLock()
	calls = mock.calls.IsCsvImported
	mock.lockIsCsvImported.RUnlock()
	return calls
}

// SetCsvImported calls SetCsvImportedFunc.
func (mock *settingsRepositoryMock) SetCsvImported(contextMoqParam context.Context) error {
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockSetCsvImported.Lock()
	mock.calls.SetCsvImported = append(mock.calls.SetCsvImported, callInfo)
	mock.lockSetCsvImported.Unlock()
	if mock.SetCsvImportedFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.SetCsvImportedFunc(contextMoqParam)
}

// SetCsvImportedCalls gets all the calls that were made to SetCsvImported.
// Check the length with:
//
//	len(mockedsettingsRepository.SetCsvImportedCalls())
func (mock *settingsRepositoryMock) SetCsvImportedCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockSetCsvImported.RLock()
	calls = mock.calls.SetCsvImported
	mock.lockSetCsvImported.RUnlock()
	return calls
}

// Ensure, that assetsRepositoryMock does implement assetsRepository.
// If this is not the case, regenerate this file with moq.
var _ assetsRepository = &assetsRepositoryMock{}

// assetsRepositoryMock is a mock implementation of assetsRepository.
//
//	func TestSomethingThatUsesassetsRepository(t *testing.T) {
//
//		// make and configure a mocked assetsRepository
//		mockedassetsRepository := &assetsRepositoryMock{
//			UpsertFunc: func(contextMoqParam context.Context, asset entities.Asset) error {
//				panic("mock out the Upsert method")
//			},
//		}
//
//		// use mockedassetsRepository in code that requires assetsRepository
//		// and then make assertions.
//
//	}
type assetsRepositoryMock struct {
	// UpsertFunc mocks the Upsert method.
	UpsertFunc func(contextMoqParam context.Context, asset entities.Asset) error

	// calls tracks calls to the methods.
	calls struct {
		// Upsert holds details about calls to the Upsert method.
		Upsert []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Asset is the asset argument value.
			Asset entities.Asset
		}
	}
	lockUpsert sync.RWMutex
}

// Upsert calls UpsertFunc.
func (mock *assetsRepositoryMock) Upsert(contextMoqParam context.Context, asset entities.Asset) error {
	callInfo := struct {
		ContextMoqParam context.Context
		Asset           entities.Asset
	}{
		ContextMoqParam: contextMoqParam,
		Asset:           asset,
	}
	mock.lockUpsert.Lock()
	mock.calls.Upsert = append(mock.calls.Upsert, callInfo)
	mock.lockUpsert.Unlock()
	if mock.UpsertFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.UpsertFunc(contextMoqParam, asset)
}

// UpsertCalls gets all the calls that were made to Upsert.
// Check the length with:
//
//	len(mockedassetsRepository.UpsertCalls())
func (mock *assetsRepositoryMock) UpsertCalls() []struct {
	ContextMoqParam context.Context
	Asset           entities.Asset
} {
	var calls []struct {
		ContextMoqParam context.Context
		Asset           entities.Asset
	}
	mock.lockUpsert.RLock()
	calls = mock.calls.Upsert
	mock.lockUpsert.RUnlock()
	return calls
}

// Ensure, that pricesRepositoryMock does implement pricesRepository.
// If this is not the case, regenerate this file with moq.
var _ pricesRepository = &pricesRepositoryMock{}

// pricesRepositoryMock is a mock implementation of pricesRepository.
//
//	func TestSomethingThatUsespricesRepository(t *testing.T) {
//
//		// make and configure a mocked pricesRepository
//		mockedpricesRepository := &pricesRepositoryMock{
//			DeleteFunc: func(contextMoqParam context.Context) error {
//				panic("mock out the Delete method")
//			},
//			SavePricesBatchFunc: func(contextMoqParam context.Context, prices []entities.Price) error {
//				panic("mock out the SavePricesBatch method")
//			},
//		}
//
//		// use mockedpricesRepository in code that requires pricesRepository
//		// and then make assertions.
//
//	}
type pricesRepositoryMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(contextMoqParam context.Context) error

	// SavePricesBatchFunc mocks the SavePricesBatch method.
	SavePricesBatchFunc func(contextMoqParam context.Context, prices []entities.Price) error

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// SavePricesBatch holds details about calls to the SavePricesBatch method.
		SavePricesBatch []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Prices is the prices argument value.
			Prices []entities.Price
		}
	}
	lockDelete          sync.RWMutex
	lockSavePricesBatch sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *pricesRepositoryMock) Delete(contextMoqParam context.Context) error {
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	if mock.DeleteFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.DeleteFunc(contextMoqParam)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedpricesRepository.DeleteCalls())
func (mock *pricesRepositoryMock) DeleteCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// SavePricesBatch calls SavePricesBatchFunc.
func (mock *pricesRepositoryMock) SavePricesBatch(contextMoqParam context.Context, prices []entities.Price) error {
	callInfo := struct {
		ContextMoqParam context.Context
		Prices          []entities.Price
	}{
		ContextMoqParam: contextMoqParam,
		Prices:          prices,
	}
	mock.lockSavePricesBatch.Lock()
	mock.calls.SavePricesBatch = append(mock.calls.SavePricesBatch, callInfo)
	mock.lockSavePricesBatch.Unlock()
	if mock.SavePricesBatchFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.SavePricesBatchFunc(contextMoqParam, prices)
}

// SavePricesBatchCalls gets all the calls that were made to SavePricesBatch.
// Check the length with:
//
//	len(mockedpricesRepository.SavePricesBatchCalls())
func (mock *pricesRepositoryMock) SavePricesBatchCalls() []struct {
	ContextMoqParam context.Context
	Prices          []entities.Price
} {
	var calls []struct {
		ContextMoqParam context.Context
		Prices          []entities.Price
	}
	mock.lockSavePricesBatch.RLock()
	calls = mock.calls.SavePricesBatch
	mock.lockSavePricesBatch.RUnlock()
	return calls
}

// Ensure, that portfolioRepositoryMock does implement portfolioRepository.
// If this is not the case, regenerate this file with moq.
var _ portfolioRepository = &portfolioRepositoryMock{}

// portfolioRepositoryMock is a mock implementation of portfolioRepository.
//
//	func TestSomethingThatUsesportfolioRepository(t *testing.T) {
//
//		// make and configure a mocked portfolioRepository
//		mockedportfolioRepository := &portfolioRepositoryMock{
//			UpsertFunc: func(contextMoqParam context.Context, portfolio entities.Portfolio) error {
//				panic("mock out the Upsert method")
//			},
//		}
//
//		// use mockedportfolioRepository in code that requires portfolioRepository
//		// and then make assertions.
//
//	}
type portfolioRepositoryMock struct {
	// UpsertFunc mocks the Upsert method.
	UpsertFunc func(contextMoqParam context.Context, portfolio entities.Portfolio) error

	// calls tracks calls to the methods.
	calls struct {
		// Upsert holds details about calls to the Upsert method.
		Upsert []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Portfolio is the portfolio argument value.
			Portfolio entities.Portfolio
		}
	}
	lockUpsert sync.RWMutex
}

// Upsert calls UpsertFunc.
func (mock *portfolioRepositoryMock) Upsert(contextMoqParam context.Context, portfolio entities.Portfolio) error {
	callInfo := struct {
		ContextMoqParam context.Context
		Portfolio       entities.Portfolio
	}{
		ContextMoqParam: contextMoqParam,
		Portfolio:       portfolio,
	}
	mock.lockUpsert.Lock()
	mock.calls.Upsert = append(mock.calls.Upsert, callInfo)
	mock.lockUpsert.Unlock()
	if mock.UpsertFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.UpsertFunc(contextMoqParam, portfolio)
}

// UpsertCalls gets all the calls that were made to Upsert.
// Check the length with:
//
//	len(mockedportfolioRepository.UpsertCalls())
func (mock *portfolioRepositoryMock) UpsertCalls() []struct {
	ContextMoqParam context.Context
	Portfolio       entities.Portfolio
} {
	var calls []struct {
		ContextMoqParam context.Context
		Portfolio       entities.Portfolio
	}
	mock.lockUpsert.RLock()
	calls = mock.calls.Upsert
	mock.lockUpsert.RUnlock()
	return calls
}

// Ensure, that tradesRepositoryMock does implement tradesRepository.
// If this is not the case, regenerate this file with moq.
var _ tradesRepository = &tradesRepositoryMock{}

// tradesRepositoryMock is a mock implementation of tradesRepository.
//
//	func TestSomethingThatUsestradesRepository(t *testing.T) {
//
//		// make and configure a mocked tradesRepository
//		mockedtradesRepository := &tradesRepositoryMock{
//			DeleteFunc: func(contextMoqParam context.Context) error {
//				panic("mock out the Delete method")
//			},
//			SaveTradesBatchFunc: func(contextMoqParam context.Context, trades []entities.Trade) error {
//				panic("mock out the SaveTradesBatch method")
//			},
//		}
//
//		// use mockedtradesRepository in code that requires tradesRepository
//		// and then make assertions.
//
//	}
type tradesRepositoryMock struct {
	// DeleteFunc mocks the Delete method.
	DeleteFunc func(contextMoqParam context.Context) error

	// SaveTradesBatchFunc mocks the SaveTradesBatch method.
	SaveTradesBatchFunc func(contextMoqParam context.Context, trades []entities.Trade) error

	// calls tracks calls to the methods.
	calls struct {
		// Delete holds details about calls to the Delete method.
		Delete []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
		}
		// SaveTradesBatch holds details about calls to the SaveTradesBatch method.
		SaveTradesBatch []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// Trades is the trades argument value.
			Trades []entities.Trade
		}
	}
	lockDelete          sync.RWMutex
	lockSaveTradesBatch sync.RWMutex
}

// Delete calls DeleteFunc.
func (mock *tradesRepositoryMock) Delete(contextMoqParam context.Context) error {
	callInfo := struct {
		ContextMoqParam context.Context
	}{
		ContextMoqParam: contextMoqParam,
	}
	mock.lockDelete.Lock()
	mock.calls.Delete = append(mock.calls.Delete, callInfo)
	mock.lockDelete.Unlock()
	if mock.DeleteFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.DeleteFunc(contextMoqParam)
}

// DeleteCalls gets all the calls that were made to Delete.
// Check the length with:
//
//	len(mockedtradesRepository.DeleteCalls())
func (mock *tradesRepositoryMock) DeleteCalls() []struct {
	ContextMoqParam context.Context
} {
	var calls []struct {
		ContextMoqParam context.Context
	}
	mock.lockDelete.RLock()
	calls = mock.calls.Delete
	mock.lockDelete.RUnlock()
	return calls
}

// SaveTradesBatch calls SaveTradesBatchFunc.
func (mock *tradesRepositoryMock) SaveTradesBatch(contextMoqParam context.Context, trades []entities.Trade) error {
	callInfo := struct {
		ContextMoqParam context.Context
		Trades          []entities.Trade
	}{
		ContextMoqParam: contextMoqParam,
		Trades:          trades,
	}
	mock.lockSaveTradesBatch.Lock()
	mock.calls.SaveTradesBatch = append(mock.calls.SaveTradesBatch, callInfo)
	mock.lockSaveTradesBatch.Unlock()
	if mock.SaveTradesBatchFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.SaveTradesBatchFunc(contextMoqParam, trades)
}

// SaveTradesBatchCalls gets all the calls that were made to SaveTradesBatch.
// Check the length with:
//
//	len(mockedtradesRepository.SaveTradesBatchCalls())
func (mock *tradesRepositoryMock) SaveTradesBatchCalls() []struct {
	ContextMoqParam context.Context
	Trades          []entities.Trade
} {
	var calls []struct {
		ContextMoqParam context.Context
		Trades          []entities.Trade
	}
	mock.lockSaveTradesBatch.RLock()
	calls = mock.calls.SaveTradesBatch
	mock.lockSaveTradesBatch.RUnlock()
	return calls
}
