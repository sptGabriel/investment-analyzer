// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package mocks

import (
	"context"
	"github.com/sptGabriel/investment-analyzer/domain/entities"
	"github.com/sptGabriel/investment-analyzer/domain/ports"
	"sync"
	"time"
)

// Ensure, that PricesRepositoryMock does implement ports.PricesRepository.
// If this is not the case, regenerate this file with moq.
var _ ports.PricesRepository = &PricesRepositoryMock{}

// PricesRepositoryMock is a mock implementation of ports.PricesRepository.
//
//	func TestSomethingThatUsesPricesRepository(t *testing.T) {
//
//		// make and configure a mocked ports.PricesRepository
//		mockedPricesRepository := &PricesRepositoryMock{
//			FindOneByTimeFunc: func(contextMoqParam context.Context, findOneByTimeInput ports.FindOneByTimeInput) (entities.Price, error) {
//				panic("mock out the FindOneByTime method")
//			},
//		}
//
//		// use mockedPricesRepository in code that requires ports.PricesRepository
//		// and then make assertions.
//
//	}
type PricesRepositoryMock struct {
	// FindOneByTimeFunc mocks the FindOneByTime method.
	FindOneByTimeFunc func(contextMoqParam context.Context, findOneByTimeInput ports.FindOneByTimeInput) (entities.Price, error)

	// calls tracks calls to the methods.
	calls struct {
		// FindOneByTime holds details about calls to the FindOneByTime method.
		FindOneByTime []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// FindOneByTimeInput is the findOneByTimeInput argument value.
			FindOneByTimeInput ports.FindOneByTimeInput
		}
	}
	lockFindOneByTime sync.RWMutex
}

// FindOneByTime calls FindOneByTimeFunc.
func (mock *PricesRepositoryMock) FindOneByTime(contextMoqParam context.Context, findOneByTimeInput ports.FindOneByTimeInput) (entities.Price, error) {
	callInfo := struct {
		ContextMoqParam    context.Context
		FindOneByTimeInput ports.FindOneByTimeInput
	}{
		ContextMoqParam:    contextMoqParam,
		FindOneByTimeInput: findOneByTimeInput,
	}
	mock.lockFindOneByTime.Lock()
	mock.calls.FindOneByTime = append(mock.calls.FindOneByTime, callInfo)
	mock.lockFindOneByTime.Unlock()
	if mock.FindOneByTimeFunc == nil {
		var (
			priceOut entities.Price
			errOut   error
		)
		return priceOut, errOut
	}
	return mock.FindOneByTimeFunc(contextMoqParam, findOneByTimeInput)
}

// FindOneByTimeCalls gets all the calls that were made to FindOneByTime.
// Check the length with:
//
//	len(mockedPricesRepository.FindOneByTimeCalls())
func (mock *PricesRepositoryMock) FindOneByTimeCalls() []struct {
	ContextMoqParam    context.Context
	FindOneByTimeInput ports.FindOneByTimeInput
} {
	var calls []struct {
		ContextMoqParam    context.Context
		FindOneByTimeInput ports.FindOneByTimeInput
	}
	mock.lockFindOneByTime.RLock()
	calls = mock.calls.FindOneByTime
	mock.lockFindOneByTime.RUnlock()
	return calls
}

// Ensure, that TradesRepositoryMock does implement ports.TradesRepository.
// If this is not the case, regenerate this file with moq.
var _ ports.TradesRepository = &TradesRepositoryMock{}

// TradesRepositoryMock is a mock implementation of ports.TradesRepository.
//
//	func TestSomethingThatUsesTradesRepository(t *testing.T) {
//
//		// make and configure a mocked ports.TradesRepository
//		mockedTradesRepository := &TradesRepositoryMock{
//			FindTradesByRangeFunc: func(ctx context.Context, start time.Time, end time.Time) ([]entities.Trade, error) {
//				panic("mock out the FindTradesByRange method")
//			},
//		}
//
//		// use mockedTradesRepository in code that requires ports.TradesRepository
//		// and then make assertions.
//
//	}
type TradesRepositoryMock struct {
	// FindTradesByRangeFunc mocks the FindTradesByRange method.
	FindTradesByRangeFunc func(ctx context.Context, start time.Time, end time.Time) ([]entities.Trade, error)

	// calls tracks calls to the methods.
	calls struct {
		// FindTradesByRange holds details about calls to the FindTradesByRange method.
		FindTradesByRange []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Start is the start argument value.
			Start time.Time
			// End is the end argument value.
			End time.Time
		}
	}
	lockFindTradesByRange sync.RWMutex
}

// FindTradesByRange calls FindTradesByRangeFunc.
func (mock *TradesRepositoryMock) FindTradesByRange(ctx context.Context, start time.Time, end time.Time) ([]entities.Trade, error) {
	callInfo := struct {
		Ctx   context.Context
		Start time.Time
		End   time.Time
	}{
		Ctx:   ctx,
		Start: start,
		End:   end,
	}
	mock.lockFindTradesByRange.Lock()
	mock.calls.FindTradesByRange = append(mock.calls.FindTradesByRange, callInfo)
	mock.lockFindTradesByRange.Unlock()
	if mock.FindTradesByRangeFunc == nil {
		var (
			tradesOut []entities.Trade
			errOut    error
		)
		return tradesOut, errOut
	}
	return mock.FindTradesByRangeFunc(ctx, start, end)
}

// FindTradesByRangeCalls gets all the calls that were made to FindTradesByRange.
// Check the length with:
//
//	len(mockedTradesRepository.FindTradesByRangeCalls())
func (mock *TradesRepositoryMock) FindTradesByRangeCalls() []struct {
	Ctx   context.Context
	Start time.Time
	End   time.Time
} {
	var calls []struct {
		Ctx   context.Context
		Start time.Time
		End   time.Time
	}
	mock.lockFindTradesByRange.RLock()
	calls = mock.calls.FindTradesByRange
	mock.lockFindTradesByRange.RUnlock()
	return calls
}

// Ensure, that PortfolioRepositoryMock does implement ports.PortfolioRepository.
// If this is not the case, regenerate this file with moq.
var _ ports.PortfolioRepository = &PortfolioRepositoryMock{}

// PortfolioRepositoryMock is a mock implementation of ports.PortfolioRepository.
//
//	func TestSomethingThatUsesPortfolioRepository(t *testing.T) {
//
//		// make and configure a mocked ports.PortfolioRepository
//		mockedPortfolioRepository := &PortfolioRepositoryMock{
//			FindOneFunc: func(contextMoqParam context.Context, v entities.PortfolioID) (entities.Portfolio, error) {
//				panic("mock out the FindOne method")
//			},
//		}
//
//		// use mockedPortfolioRepository in code that requires ports.PortfolioRepository
//		// and then make assertions.
//
//	}
type PortfolioRepositoryMock struct {
	// FindOneFunc mocks the FindOne method.
	FindOneFunc func(contextMoqParam context.Context, v entities.PortfolioID) (entities.Portfolio, error)

	// calls tracks calls to the methods.
	calls struct {
		// FindOne holds details about calls to the FindOne method.
		FindOne []struct {
			// ContextMoqParam is the contextMoqParam argument value.
			ContextMoqParam context.Context
			// V is the v argument value.
			V entities.PortfolioID
		}
	}
	lockFindOne sync.RWMutex
}

// FindOne calls FindOneFunc.
func (mock *PortfolioRepositoryMock) FindOne(contextMoqParam context.Context, v entities.PortfolioID) (entities.Portfolio, error) {
	callInfo := struct {
		ContextMoqParam context.Context
		V               entities.PortfolioID
	}{
		ContextMoqParam: contextMoqParam,
		V:               v,
	}
	mock.lockFindOne.Lock()
	mock.calls.FindOne = append(mock.calls.FindOne, callInfo)
	mock.lockFindOne.Unlock()
	if mock.FindOneFunc == nil {
		var (
			portfolioOut entities.Portfolio
			errOut       error
		)
		return portfolioOut, errOut
	}
	return mock.FindOneFunc(contextMoqParam, v)
}

// FindOneCalls gets all the calls that were made to FindOne.
// Check the length with:
//
//	len(mockedPortfolioRepository.FindOneCalls())
func (mock *PortfolioRepositoryMock) FindOneCalls() []struct {
	ContextMoqParam context.Context
	V               entities.PortfolioID
} {
	var calls []struct {
		ContextMoqParam context.Context
		V               entities.PortfolioID
	}
	mock.lockFindOne.RLock()
	calls = mock.calls.FindOne
	mock.lockFindOne.RUnlock()
	return calls
}
